priority -50

global !p
# A overkill(dirty) table with automatic alignment feature
def create_table(snip):
	# retrieving single line from current string and treat it like tabstops count
	placeholders_string = snip.buffer[snip.line].strip()
	rows_amount = int(placeholders_string[0])
	columns_amount = int(placeholders_string[1])

	prefix_str = "from vimsnippets import display_width;"

	# erase current line
	snip.buffer[snip.line] = ""

	# create anonymous snippet with expected content and number of tabstops
	anon_snippet_title = "| "
	anon_snippet_delimiter = "|"
	for col in range(1, columns_amount+1):
		sync_rows = [x*columns_amount+col for x in range(rows_amount+1)]
		sync_str = ",".join(["t[{0}]".format(x) for x in sync_rows])
		max_width_str = "max(list(map(display_width, [" + sync_str + "])))"
		cur_width_str = "display_width(t[" + str(col) + "])"
		rv_val = "(" + max_width_str + "-" + cur_width_str + ")*' '"
		anon_snippet_title += "${" + str(col)  + ":head" + str(col)\
			+ "}`!p " + prefix_str + "snip.rv=" + rv_val + "` | "
		anon_snippet_delimiter += ":`!p " + prefix_str + "snip.rv = "\
			+ max_width_str + "*'-'" + "`-|"

	anon_snippet_title += "\n"

	anon_snippet_delimiter += "\n"
	anon_snippet_body = ""
	for row in range(1, rows_amount+1):
		body_row = "| "
		for col in range(1, columns_amount+1):
			sync_rows = [x*columns_amount+col for x in range(rows_amount+1)]
			sync_str = ",".join(["t[{0}]".format(x) for x in sync_rows])
			max_width_str = "max(list(map(display_width, [" + sync_str + "])))"
			cur_width_str = "display_width(t[" + str(row*columns_amount+col) + "])"
			rv_val = "(" + max_width_str + "-" + cur_width_str + ")*' '"
			placeholder = "R{0}C{1}".format(row, col)
			body_row += "${" + str(row*columns_amount+col)  + ":" + placeholder\
				+ "}`!p " + prefix_str + "snip.rv=" + rv_val + "` | "

		body_row += "\n"
		anon_snippet_body += body_row

	anon_snippet_table = anon_snippet_title + anon_snippet_delimiter + anon_snippet_body

	# expand anonymous snippet
	snip.expand_anon(anon_snippet_table)

texMathZones = ['texMathZone'+x for x in ['A', 'AS', 'B', 'BS', 'C', 'CS', 'D',
								'DS', 'E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS', 'J', 'JS', 'K',
								'KS', 'L', 'LS', 'DS', 'V', 'W', 'X', 'Y', 'Z']]
texIgnoreMathZones = ['texMathText']
texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")
ignore = texIgnoreMathZoneIds[0]

def math():
	synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
	try:
		first = next(i for i in reversed(synstackids) if i in texIgnoreMathZoneIds or i in texMathZoneIds)
		return first != ignore
	except StopIteration:
		return False

def math():
	return vim.eval('vimtex#syntax#in_mathzone()') == '1'

def not_math():
	return vim.eval('vimtex#syntax#in_mathzone()') == '0'

def comment(): 
	return vim.eval('vimtex#syntax#in_comment()') == '1'

def env(name):
	[x,y] = vim.eval("vimtex#env#is_inside('" + name + "')") 
	return x != '0' and y != '0'
endglobal


###########################
# Sections and Paragraphs #
###########################

snippet sec "Section" b
# ${1:Section Name} #
$0
endsnippet

snippet ssec "Sub Section" b
## ${1:Section Name} ##
$0
endsnippet

snippet sssec "SubSub Section" b
### ${1:Section Name} ###
$0
endsnippet

snippet par "Paragraph" b
#### ${1:Paragraph Name} ####
$0
endsnippet

snippet spar "Paragraph" b
##### ${1:Paragraph Name} #####
$0
endsnippet


###################
# Text formatting #
###################

snippet * "italics"
*${1:${VISUAL}}*$0
endsnippet

snippet ** "bold"
**${1:${VISUAL}}**$0
endsnippet

snippet *** "bold italics"
***${1:${VISUAL}}***$0
endsnippet

snippet /* "Comment"
<!-- ${1:${VISUAL}} -->$0
endsnippet


################
# Common stuff #
################

snippet link "Link to something"
[${1:${VISUAL:Text}}](${3:https://${2:www.url.com}})$0
endsnippet

snippet img "Image"
![${1:pic alt}](${2:path}${3/.+/ "/}${3:opt title}${3/.+/"/})$0
endsnippet

snippet ilc "Inline Code" i
\`${1:${VISUAL}}\`$0
endsnippet

snippet cbl "Codeblock" b
\`\`\`$1
${2:${VISUAL}}
\`\`\`
$0
endsnippet

snippet refl "Reference Link"
[${1:${VISUAL:Text}}][${2:id}]$0

[$2]:${4:https://${3:www.url.com}} "${5:$4}"
endsnippet

snippet fnt "Footnote"
[^${1:${VISUAL:Footnote}}]$0

[^$1]:${2:Text}
endsnippet

snippet detail "Disclosure"
<details${3: open=""}>
	${1:<summary>${2}</summary>}$0
</details>
endsnippet

post_jump "create_table(snip)"
snippet "tb([1-9][1-9])" "Fancy table" br
`!p snip.rv = match.group(1)`
endsnippet


###########################
# Inline and Display Math #
###########################

snippet ilm "Inline Math" wA
$${VISUAL}$1$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
    snip.rv = ' '
else:
    snip.rv = ''
`$2
endsnippet

snippet dm "Display Math" wA
$$
${VISUAL}$1
$$${0}
endsnippet


######################################################
# ASCII MATH LIKE SNIPPETS => =< <= :. ... ** XX |-> #
######################################################

# -- -> \overline{}
context "math()"
snippet -- "Bar" i
\overline{$1}$0
endsnippet

# x-- -> \overline{x}
# (xx)-- -> \overline{xxx}
context "math()"
snippet '(\S|\(.*?\))--' "Bar" riA
\overline{`!p snip.rv=match.group(1).replace('(', '').replace(')', '')`}
endsnippet

# .. -> \dot{}
context "math()"
snippet .. "Dot" i
\dot{$1}$0
endsnippet

# x.. -> \dot{x}
context "math()"
snippet '(\S)\.\.' "Dot" riA
\dot{`!p snip.rv=match.group(1)`}
endsnippet

# ,, -> \vec{}
context "math()"
snippet ,, "Vec" i
\vec{$1}$0
endsnippet

# x,, -> \vec{x}
context "math()"
snippet '(\S),,' "Vec" riA
\vec{`!p snip.rv=match.group(1)`}
endsnippet

# ,. -> \hat{}
context "math()"
snippet ,. "Hat" i
\hat{$1}$0
endsnippet

# x,. -> \hat{x}
context "math()"
snippet '(\S)\,\.' "Hat" riA
\hat{`!p snip.rv=match.group(1)`}
endsnippet

# <a| = \bra{a}
# <| = \bra{}
context "math()"
snippet '\<(.*?)\|' "Bra" riA
\bra{`!p snip.rv = match.group(1).replace('q', f'\psi').replace('f', f'\phi')`}
endsnippet

# |a> = \ket{a}
# |> = \ket{}
context "math()"
snippet '\|(.*?)\>' "Ket" riA
\ket{`!p snip.rv = match.group(1).replace('q', f'\psi').replace('f', f'\phi')`}
endsnippet

# \bra{a}a> = \braket{a|a}
# \ket{a}a> = \braket{a|a}
context "math()"
snippet '\\(bra|ket){(.*?)}([^\|]*?)\>' "Braket" riA
\braket{`!p snip.rv = match.group(2)`|`!p snip.rv = match.group(3).replace('q', f'\psi').replace('f', f'\phi')`}
endsnippet

# exp -> \exp
context "math()"
snippet 'exp' "Some Functions" rwA
\\exp
endsnippet

# sin -> \sin
# cos -> \cos
# tan -> \tan
# cot -> \cot
# sec -> \sec
# csc -> \csc
context "math()"
snippet '(?<!\\)(sin|cos|tan|cot|sec|csc)' "Trig Functions" rwA
\\`!p snip.rv = match.group(1)`
endsnippet

# log -> \log
# ln -> \ln
context "math()"
snippet '(?<!\\)(log|ln)' "Log Functions" rwA
\\`!p snip.rv = match.group(1)`
endsnippet

# ffnc -> f(${1:x})
context "math()"
snippet '([a-zA-Z])fnc' "Create Function" rwA
`!p snip.rv = match.group(1)`(${1:x})
endsnippet

# fofx -> f(x) = x
context "math()"
snippet '([a-zA-Z])of([a-zA-Z])' "Create Function" rwA
`!p snip.rv = match.group(1)`(`!p snip.rv = match.group(2)`) = ${1:`!p snip.rv = match.group(2)`}
endsnippet

# fof<x,y,z> -> f(x,y,z) = x,y,z
context "math()"
snippet '(.)of\<(.*?)\>' "Create Function" rwA
`!p snip.rv = match.group(1)`(`!p snip.rv = match.group(2)`) = ${1:`!p snip.rv = match.group(2)`}
endsnippet

# fun -> f \:  \mathbb{R} \to \mathbb{R} \:
context "math()"
snippet fun "F something Subset of R" iA
f : $1 \subset \mathbf{R} \to \mathbf{R} : $2
endsnippet

# <> -> \iff
context "math()"
snippet <> "If and only if" Ai
\iff
endsnippet

# => -> \implies
context "math()"
snippet => "Implies" Ai
\implies
endsnippet

# <= -> \impliedby
context "math()"
snippet <= "Implied by" Ai
\impliedby
endsnippet

# !> -> \mapsto
context "math()"
snippet !> "Mapsto" Ai
\mapsto
endsnippet

# +- -> \pm
context "math()"
snippet +- "Plus minus" Ai
\pm
endsnippet

# -+ -> \mp
context "math()"
snippet -+ "Minus plus" Ai
\mp
endsnippet

# xx -> \times
context "math()"
snippet xx "Times" iA
\times
endsnippet

# .s -> \ldots
snippet .s "Straight dots" Ai
\ldots
endsnippet

# .v -> \vdots
snippet .v "Vertical dots" Ai
\vdots
endsnippet

# .c -> \cdots
snippet .c "Dots above line" Ai
\cdots
endsnippet

# .d -> \ddots
snippet .d "Diagonal dots" Ai
\ddots
endsnippet

# :. -> \therefore
snippet :. "Therefore" Ai
\therefore
endsnippet

# oo -> \infty
context "math()"
snippet oo "Infinity" Ai
\infty
endsnippet

# oc -> \propto
context "math()"
snippet oc "Proportional" Ai
\propto
endsnippet

# || -> \mid
context "math()"
snippet || "mid" iA
\mid
endsnippet

# cc -> \subset
context "math()"
snippet cc "subset" Ai
\subset
endsnippet

# Cc -> \subseteq
context "math()"
snippet Cc "Sub Set Equal" wA
\\subseteq
endsnippet

# OO -> \emptyset
context "math()"
snippet OO "emptyset" iA
\emptyset
endsnippet

# set -> \{  \}
context "math()"
snippet set "set" wA
\\{ $1 \\}$0
endsnippet

# notin -> \not\in
context "math()"
snippet notin "not in " iA
\not\in
endsnippet

# ap -> \cap
context "math()"
snippet	Nn "cap" iA
\cap
endsnippet

# up -> \cup
context "math()"
snippet UU "cup" iA
\cup
endsnippet

context "math()"
snippet uuu "bigcup" iA
\bigcup_{${1:i \in ${2: I}}} $0
endsnippet

context "math()"
snippet nnn "bigcap" iA
\bigcap_{${1:i \in ${2: I}}} $0
endsnippet

# <! -> \triangleleft
context "math()"
snippet <! "normal" iA
\triangleleft
endsnippet

# <-> -> \diamond
context "math()"
snippet <-> "hokje" iA
\diamond
endsnippet

# ~~ -> \sim
context "math()"
snippet ~~ "~" iA
\sim 
endsnippet


#####################
# Equality snippets #
#####################

# << -> \ll
context "math()"
snippet << "Less than" Ai
\ll
endsnippet

# >> -> \gg
context "math()"
snippet >> "Greater than" Ai
\gg
endsnippet

# <= -> \le
context "math()"
snippet <= "Less than or equal to" Ai
\le
endsnippet

# >= -> \ge
context "math()"
snippet >= "Greater than or equal to" Ai
\ge
endsnippet

# != -> \ne
context "math()"
snippet != "Not equal to" Ai
\ne
endsnippet

# ~= -> \approx
context "math()"
snippet ~= "Approximately" Ai
\approx
endsnippet

# === -> \equiv
context "math()"
snippet === "Equivalent" Ai
\equiv
endsnippet

# dfq -> \overset{\underset{\mathrm{def}}{}}{=}
context "math()"
snippet dfq "Defeq" Ai
\overset{\underset{\mathrm{def}}{}}{=}
endsnippet


########################
# SUB AND SUPERSCRIPT. #
########################

# x3 -> x_3
context "math()"
snippet '([A-Za-z])(\d)' "Auto subscript 1" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

# x_33 -> x_{33}
context "math()"
snippet '([A-Za-z])_(\d\d)' "Auto subscript 2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

# x_{333}3 -> x_{3333}
context "math()"
snippet '([A-Za-z])_\{(\d+)\}(\d)' "Auto subscript 3+" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2) + match.group(3)`}
endsnippet

# sq -> ^{2}
context "math()"
snippet sq "Square" iA
^{2}
endsnippet

# cb -> ^{3}
context "math()"
snippet cb "Cube" iA
^{3}
endsnippet

# comp -> ^{c}
context "math()"
snippet compl "Complement" iA
^{c}
endsnippet

# inv -> ^{-}
context "math()"
snippet inv "Inverse" iA
^{-$1}$0
endsnippet

# ss -> ^{}
context "math()"
snippet ss "Superscript" iA
^{$1}$0
endsnippet

# deg -> ^{\circ}
context "math()"
snippet deg "Degree Symbol" iA
^{\circ}$0
endsnippet

# sr -> \sqrt{}
context "math()"
snippet sr "Square root" iA
\sqrt{$1}$0
endsnippet

# nr -> \sqrt[]{}
context "math()"
snippet nr "n Root" iA
\sqrt[$1]{$2}$0
endsnippet


#############
# FRACTIONS #
#############

# // -> \frac{}{}
context "math()"
snippet // "Fraction" iA
\\frac{${VISUAL}$1}{$2}$0
endsnippet

# 4\pi/ -> \frac{4\pi}{}
context "math()"
snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)/' "Fraction" wrA
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet

# (4\pi \times 1)/ -> \frac{4\pi \times 1}{}
context "math()"
snippet '^.*\)/' "() Fraction" wrA
`!p
stripped = match.string[:-1]
depth = 0
i = len(stripped) - 1
while True:
	if stripped[i] == ')': depth += 1
	if stripped[i] == '(': depth -= 1
	if depth == 0: break;
	i -= 1
snip.rv = stripped[0:i] + "\\frac{" + stripped[i+1:-1] + "}"
`{$1}$0
endsnippet


#########################
# SUMS AND PRODUCTS ETC #
#########################

# sum -> \sum_{n = 1}^{\infty}
context "math()"
snippet sum "Sum" wA
\sum_{${1:n = 1}}^{${2:\infty}}
endsnippet

# prod -> \prod_{}^{}
context "math()"
snippet prod "Product" wA
\prod_{$1}^{$2}$0
endsnippet

# taylor -> \sum_{n=0}^{\infty} \frac{f^{(n)}(0) \cdot x^n}{n!}
context "math()"
snippet taylor "Taylor series" wA
\sum_{n=0}^{\infty} \frac{${1:f^{(n)}(0)} \cdot ${2:x^n}}{${3:n!}}$0
endsnippet


#################
# GREEK LETTERS #
#################

context "math()"
snippet '(alp|Alp|bet|Bet|gam|Gam|del|Del|eps|Eps|zet|Zet|eta|Zet|the|The|iot|Iot|kap|Kap|lam|Lam|mu|Mu|nu|Nu|xi|Xi|omi|Omi|pi|Pi|rho|Rho|sig|Sig|tau|Tau|ups|Ups|phi|Phi|chi|Chi|psi|Psi|ome|Ome)' "All Greek Letters" riA
`!p
if match.group(1) == 'alp':
	snip.rv = '\\alpha'
elif match.group(1) == 'Alp':
	snip.rv = '\\Alpha'
elif match.group(1) == 'bet':
	snip.rv = '\\beta'
elif match.group(1) == 'Bet':
	snip.rv = '\\Beta'
elif match.group(1) == 'gam':
	snip.rv = '\\gamma'
elif match.group(1) == 'Gam':
	snip.rv = '\\Gamma'
elif match.group(1) == 'del':
	snip.rv = '\\delta'
elif match.group(1) == 'Del':
	snip.rv = '\\Delta'
elif match.group(1) == 'eps':
	snip.rv = '\\epsilon'
elif match.group(1) == 'Eps':
	snip.rv = '\\Epsilon'
elif match.group(1) == 'zet':
	snip.rv = '\\zeta'
elif match.group(1) == 'Zet':
	snip.rv = '\\Zeta'
elif match.group(1) == 'eta':
	snip.rv = '\\eta'
elif match.group(1) == 'Zet':
	snip.rv = '\\Eta'
elif match.group(1) == 'the':
	snip.rv = '\\theta'
elif match.group(1) == 'The':
	snip.rv = '\\Theta'
elif match.group(1) == 'iot':
	snip.rv = '\\iota'
elif match.group(1) == 'Iot':
	snip.rv = '\\Iota'
elif match.group(1) == 'kap':
	snip.rv = '\\kappa'
elif match.group(1) == 'Kap':
	snip.rv = '\\Kappa'
elif match.group(1) == 'lam':
	snip.rv = '\\lambda'
elif match.group(1) == 'Lam':
	snip.rv = '\\Lambda'
elif match.group(1) == 'mu':
	snip.rv = '\\mu'
elif match.group(1) == 'Mu':
	snip.rv = '\\Mu'
elif match.group(1) == 'nu':
	snip.rv = '\\nu'
elif match.group(1) == 'Nu':
	snip.rv = '\\Nu'
elif match.group(1) == 'xi':
	snip.rv = '\\xi'
elif match.group(1) == 'Xi':
	snip.rv = '\\Xi'
elif match.group(1) == 'omi':
	snip.rv = '\\omicron'
elif match.group(1) == 'Omi':
	snip.rv = '\\Omicron'
elif match.group(1) == 'pi':
	snip.rv = '\\pi'
elif match.group(1) == 'Pi':
	snip.rv = '\\Pi'
elif match.group(1) == 'rho':
	snip.rv = '\\rho'
elif match.group(1) == 'Rho':
	snip.rv = '\\Rho'
elif match.group(1) == 'sig':
	snip.rv = '\\sigma'
elif match.group(1) == 'Sig':
	snip.rv = '\\Sigma'
elif match.group(1) == 'tau':
	snip.rv = '\\tau'
elif match.group(1) == 'Tau':
	snip.rv = '\\Tau'
elif match.group(1) == 'ups':
	snip.rv = '\\upsilon'
elif match.group(1) == 'Ups':
	snip.rv = '\\Upsilon'
elif match.group(1) == 'phi':
	snip.rv = '\\phi'
elif match.group(1) == 'Phi':
	snip.rv = '\\Phi'
elif match.group(1) == 'chi':
	snip.rv = '\\chi'
elif match.group(1) == 'Chi':
	snip.rv = '\\Chi'
elif match.group(1) == 'psi':
	snip.rv = '\\psi'
elif match.group(1) == 'Psi':
	snip.rv = '\\Psi'
elif match.group(1) == 'ome':
	snip.rv = '\\omega'
elif match.group(1) == 'Ome':
	snip.rv = '\\Omega'
`$2
endsnippet


############
# CALCULUS #
############

context "math()"
snippet prt "Delta" iwA
\partial $0
endsnippet

context "math()"
snippet int "Integral" iw
\int
endsnippet

context "math()"
snippet iint "Integral" iw
\iint
endsnippet

context "math()"
snippet iiint "Integral" iw
\iiint
endsnippet

context "math()"
snippet iiiint "Integral" iw
\iiiint
endsnippet

context "math()"
snippet into "Integral" iw
\oint
endsnippet

context "math()"
snippet intx "Integral" iw
\intx
endsnippet

# lim -> \lim_{n \to \infty}
context "math()"
snippet lim "Limit" wA
\lim_{${1:n} \to ${2:\infty}}
endsnippet

# odx -> \od{}{x}
context "math()"
snippet odx "d/dx" w
\od{$1}{x}$0
endsnippet

# ody -> \od{}{y}
context "math()"
snippet ody "d/dx" wA
\od{$1}{y}$0
endsnippet

# odt -> \od{}{t}
context "math()"
snippet odt "d/dx" w
\od{$1}{t} $0
endsnippet

# od -> \od[]{}{}
context "math()"
snippet od "d/dx" w
\od[$1]{$2}{$3} $0
endsnippet

# pd -> \pd[]{}{}
context "math()"
snippet pd "d/dx" w
\pd[$1]{$2}{$3} $0
endsnippet

# md -> \md{}{}
context "math()"
snippet md "d/dx" w
\md{$1}{$2}$0
endsnippet

# eval -> \eval{}_{}^{}
context "math()"
snippet eval "Eval int" wA
\eval{$3}_{$1}^{$2}
endsnippet

# nab -> \nabla
# grad -> \nabla
context "math()"
snippet '(nab|grad)' "Nabla" wrA
\nabla
endsnippet


#################
# REAL ANALYSIS #
#################

# ext -> \exists
context "math()"
snippet ext "Exists" wA
\exists
endsnippet

# next -> \nexists
context "math()"
snippet next "Exists" wA
\nexists
endsnippet

# lt -> \lnot
context "math()"
snippet lt "Lnot" wA
\lnot
endsnippet

# ld -> \land
context "math()"
snippet ld "Land" wA
\land
endsnippet

# for -> \forall
context "math()"
snippet for "For all" wA
\forall
endsnippet

# qd -> \qquad
context "math()"
snippet qd "Quad" wA
\qquad
endsnippet

# inn -> \in
context "math()"
snippet inn "In" wA
\in
endsnippet

# mb -> \mathbb{}
context "math()"
snippet mb "Mathbb" wA
\mathbb{$1}$0
endsnippet

# mf -> \mathbf{}
context "math()"
snippet mf "Mathbf" wA
\mathbf{$1}$0
endsnippet

# RR -> \mathbb{R}
context "math()"
snippet RR "Set of Real Numbers" wA
\mathbb{R}
endsnippet

# ZZ -> \mathbb{Z}
context "math()"
snippet ZZ "Set of Integers" wA
\mathbb{Z}
endsnippet

# QQ -> \mathbb{Q}
context "math()"
snippet QQ "Set of Rational Numbers" wA
\mathbb{Q}
endsnippet

# NN -> \mathbb{N}
context "math()"
snippet NN "Set of Natural Numbers" wA
\mathbb{N}
endsnippet

# CC -> \mathbb{C}
context "math()"
snippet CC "Set of Complex Numbers" wA
\mathbb{C}
endsnippet

########################
# MATRICES AND VECTORS #
########################

context "math()"
snippet mat "Matrix"
\begin{bmatrix}
$0
\end{bmatrix}
endsnippet

context "math()"
snippet det "Determinant matrix"
\begin{vmatrix}
$0
\end{vmatrix}
endsnippet

context "math()"
snippet vec "Vector"
\begin{pmatrix}
$0
\end{pmatrix}
endsnippet

context "math()"
snippet matil "Inline matrix"
\left[ \begin{smallmatrix}
$0
\end{smallmatrix} \right]
endsnippet

context "math()"
snippet detil "Inline determinant"
\left| \begin{smallmatrix}
$0
\end{smallmatrix} \right|
endsnippet

context "math()"
snippet vecil "Inline vector"
\left( \begin{smallmatrix}
$0
\end{smallmatrix} \right)
endsnippet

context "math()"
snippet chse "n choose p"
{${1:n} \choose ${2:p}} $0
endsnippet


#############################################
# (), [], {}, AND THEIR BIGGER COUNTERPARTS #
#############################################

# () -> \left(\right)
context "math()"
snippet () "Parenthesis" i
\left($1\right)$0
endsnippet

# {} -> \left{\right}
context "math()"
snippet {} "Parenthesis" i
\left\{$1\right\}$0
endsnippet

# [] -> \left[\right]
context "math()"
snippet [] "Parenthesis" i
\left\[$1\right\]$0
endsnippet

# ( -> \left(
context "math()"
snippet ( "Left(" i
\left(
endsnippet

# ) -> \right)
context "math()"
snippet ) "Right)" i
\right)
endsnippet

# { -> \left{
context "math()"
snippet { "Left{" i
\left{
endsnippet

# } -> \right}
context "math()"
snippet } "Right}" i
\right}
endsnippet

# [ -> \left[
context "math()"
snippet [ "Left["
\left[
endsnippet

# ] -> \right]
context "math()"
snippet ] "Right]" i
\right]
endsnippet

# vim:ft=snippets:
